// Copyright Â© 2016, Jakob Bornecrantz.  All rights reserved.
// See copyright notice in src/fourier/license.volt (BOOST ver. 1.0).
/**
 * Compare Volt JSON output to a C header file.
 */
module fourier.compare;

import watt.io : writefln;
import watt.io.file : read;

import lib.clang;  // Every clang_* function and CX* type.

import fourier.volt;
import fourier.util : getVoltString;
import fourier.walker;

/**
 * List the important differences between a C header file, and the JSON output
 * of a Volt module (presumably binding the same file).
 *
 * Params:
 *   cPath: The filename of the C file to check.
 *   jsonPath: The filename of the JSON file to check.
 */
fn listDiscrepancies(cPath: string, jsonPath: string)
{
	jsonBases := loadJson(jsonPath);
	cContext := loadC(cPath);
	scope (exit) unloadC(cContext);

	cWalker := walk(cContext.tu, false, "");

	cNames := filterBases(cWalker.mod, filter.functions);
	jsonNames := filterBases(jsonBases, filter.functions);
	nameComparison(cPath, cNames, jsonPath, jsonNames);
}

fn nameComparison(cFilename: string, cBases: Base[], jsonFilename: string, jsonBases: Base[]) bool
{
	bool pass = true;
	foreach (cBase; cBases) {
		cNamed := cast(Named)cBase;
		if (cNamed is null) {
			continue;
		}
		jsonNamed := jsonBases.getName(cNamed.name);
		if (jsonNamed is null) {
			pass = false;
			writefln("'%s' defines %s '%s' that is undefined by '%s'. [FAIL]",
				cFilename, getStringFromKind(cNamed.kind), cNamed.name, jsonFilename);
		} else {
			writefln("'%s' defines %s '%s', as does '%s'. [PASS]",
				cFilename, getStringFromKind(cNamed.kind), cNamed.name, jsonFilename);
		}
	}
	return pass;
}

/**
 * Returns a Named from bases that has the name name, or null.
 */
fn getName(bases: Base[], name: string) Named
{
	foreach (base; bases) {
		named := cast(Named)base;
		if (named is null) {
			continue;
		}
		if (named.name == name) {
			return named;
		}
	}
	return null;
}

/**
 * Temporary: List the structs names.
 */
fn listStructs(filename: string, structs: Base[])
{
	writefln("'%s' defines %s structs:", filename, structs.length);
	foreach (_struct; structs) {
		named := cast(Named)_struct;
		assert(named !is null);
		writefln("struct %s", named.name);
	}
}

/**
 * Load and parse a JSON file.
 *
 * Params:
 *   jsonPath: The path to the JSON file to parse.
 * Returns: An array of Base objects, generated by fourier.volt.parse.
 */
fn loadJson(jsonPath: string) Base[]
{
	str := cast(string)read(jsonPath);
	return parse(str);
}

/**
 * Holds pieces of information together, for libclang.
 */
struct ClangContext
{
	index: CXIndex;
	tu: CXTranslationUnit;
}

/**
 * Initialise libclang, and parse a C file.
 *
 * Params:
 *   cPath: The path to the C file to parse.
 * Returns: A ClangContext.
 */
fn loadC(cPath: string) ClangContext
{
	context: ClangContext;
	context.index = clang_createIndex(0, 0);
	args := ["-I.".ptr];
	context.tu = clang_parseTranslationUnit(context.index, cPath.ptr, args.ptr,
		cast(i32)args.length, null, 0, CXTranslationUnit_None);
	// TODO: Error handling.
	return context;
}

/**
 * Clean up a ClangContext from loadC.
 */
fn unloadC(context: ClangContext)
{
	clang_disposeTranslationUnit(context.tu);
	clang_disposeIndex(context.index);
}

/**
 * Return the Bases that match a given filter.
 *
 * Params:
 *   bases: The array of Bases to filter.
 *   dg: The filter to apply. This will be run on each member of
 *       bases, and only those which of which it returns true will
 *       be returned.
 * Returns: An array of Bases that the dg applies to, or an empty list.
 */
fn filterBases(bases: Base[], dg: filterdg) Base[]
{
	ret: Base[];
	foreach (base; bases) {
		if (dg(base)) {
			ret ~= base;
		}
		parent := cast(Parent)base;
		if (parent !is null) {
			ret ~= filterBases(parent.children, dg);
		}
	}
	return ret;
}

alias filterdg = bool delegate(Base);
private struct Filter
{
	fn publicStructs(base: Base) bool
	{
		p := cast(Parent)base;
		return base.kind == Kind.Struct && p !is null && !p.isAnonymous;
	}

	fn functions(base: Base) bool
	{
		f := cast(Function)base;
		return f !is null;
	}

	fn named(base: Base) bool
	{
		n := cast(Named)base;
		return n !is null;
	}
}
private global Filter filter;